<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            transition: background-color 0.5s;
        }
        canvas {
            background-color: #fff;
            border: 2px solid #333;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: pointer;
            image-rendering: pixelated; 
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="600" height="400"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        const CLICK_ZONES = {
            restartY: H / 2 + 50,
            homeY: H / 2 + 90
        };

        const gridSize = 40;
        const tileCount = canvas.width / gridSize; 

        let snake;
        let dx;
        let dy;
        let foodX;
        let foodY;
        let score;
        let highScore = 0; 
        let gameOver;
        let gameLoop;
        let gameStarted; 
        let inputQueue = []; 

        function drawUI() {
            ctx.font = '18px Arial';
            ctx.fillStyle = '#333';
            
            ctx.textAlign = 'start'; 
            ctx.fillText(`Score: ${score}`, 10, 25);
            
            ctx.textAlign = 'right'; 
            ctx.fillText(`High Score: ${highScore}`, W - 10, 25);
            
            ctx.textAlign = 'start'; 
        }

        function drawEndGameMessage() {
            document.body.style.backgroundColor = '#333';

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, W, H);
            
            ctx.textAlign = 'center';
            ctx.font = '40px Arial';
            ctx.fillStyle = 'white';
            ctx.fillText("GAME OVER", W / 2, H / 2 - 50); 
            
            ctx.font = '20px Arial';
            ctx.fillText(`Final Score: ${score}`, W / 2, H / 2); 
            
            ctx.fillStyle = '#4CAF50'; 
            ctx.fillText('Click to Restart', W / 2, CLICK_ZONES.restartY); 
            
            ctx.fillStyle = '#FF9800'; 
            ctx.fillText('Click to Go Home', W / 2, CLICK_ZONES.homeY); 
            
            ctx.textAlign = 'start'; 
        }

        function startGame() {
            if (gameLoop) clearInterval(gameLoop);

            snake = [{ x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) }]; 
            dx = 0;
            dy = 0;
            score = 0;
            gameOver = false;
            gameStarted = false;
            inputQueue = []; 
            
            document.body.style.backgroundColor = '#f0f0f0';
            canvas.style.filter = 'none';

            generateFood();
            
            clearCanvas();
            drawFood();
            drawSnake();
            drawUI(); 
        }

        function restartGame() {
            startGame();
        }

        function goHome() {
            if (window.parent && typeof window.parent.loadGame === 'function') {
                window.parent.loadGame('home');
            } 
            
            else {
                window.top.location.href = 'index.html'; 
            }
        }

        function main() {
            if (gameOver) return;

            processInputQueue();
            clearCanvas();
            drawFood();
            moveSnake(); 
            drawSnake();
            drawUI(); 

            if (gameOver) {
                handleGameOver();
            }
        }

        function handleGameOver() {
            clearInterval(gameLoop); 
            drawEndGameMessage(); 
        }

        function clearCanvas() {
            const color1 = '#FFFFFF';
            const color2 = '#F5F5F5';
            for (let y = 0; y < tileCount; y++) {
                for (let x = 0; x < tileCount; x++) {
                    ctx.fillStyle = (x + y) % 2 === 0 ? color1 : color2;
                    ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                }
            }
        }

        function drawSnake() {
            snake.forEach(drawSnakePart);
        }

        function drawSnakePart(snakePart) {
            ctx.fillStyle = '#008000';
            ctx.strokeStyle = '#006400';
            ctx.fillRect(snakePart.x * gridSize, snakePart.y * gridSize, gridSize, gridSize);
            ctx.strokeRect(snakePart.x * gridSize, snakePart.y * gridSize, gridSize, gridSize);
        }

        function drawFood() {
            ctx.fillStyle = '#FF0000';
            ctx.strokeStyle = '#B22222';
            ctx.fillRect(foodX * gridSize, foodY * gridSize, gridSize, gridSize);
            ctx.strokeRect(foodX * gridSize, foodY * gridSize, gridSize, gridSize);
        }

        function moveSnake() {
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };
            snake.unshift(head);

            const didEatFood = (snake[0].x === foodX && snake[0].y === foodY);
            if (didEatFood) {
                score += 10;
                if (score > highScore) highScore = score;
                generateFood();
            } else {
                snake.pop(); 
            }

            if (checkCollision()) {
                gameOver = true;
            }
        }

        function processInputQueue() {
            if (inputQueue.length > 0) {
                const key = inputQueue.shift(); 
                const goingUp = (dy === -1);
                const goingDown = (dy === 1);
                const goingRight = (dx === 1);
                const goingLeft = (dx === -1);

                if (key === 'Left' && !goingRight) { dx = -1; dy = 0; }
                else if (key === 'Right' && !goingLeft) { dx = 1; dy = 0; }
                else if (key === 'Up' && !goingDown) { dx = 0; dy = -1; }
                else if (key === 'Down' && !goingUp) { dx = 0; dy = 1; }
            }
        }

        function changeDirection(event) {
            const keyPressed = event.key;
            const LEFT_KEY = 'ArrowLeft';
            const RIGHT_KEY = 'ArrowRight';
            const UP_KEY = 'ArrowUp';
            const DOWN_KEY = 'ArrowDown';

            if (![LEFT_KEY, RIGHT_KEY, UP_KEY, DOWN_KEY].includes(keyPressed) &&
                !['Left', 'Right', 'Up', 'Down'].includes(keyPressed)) return;

            let direction = '';
            if (keyPressed === LEFT_KEY || keyPressed === 'Left') direction = 'Left';
            else if (keyPressed === RIGHT_KEY || keyPressed === 'Right') direction = 'Right';
            else if (keyPressed === UP_KEY || keyPressed === 'Up') direction = 'Up';
            else if (keyPressed === DOWN_KEY || keyPressed === 'Down') direction = 'Down';

            if (!gameStarted) {
                if (direction === 'Left') { dx = -1; dy = 0; }
                else if (direction === 'Right') { dx = 1; dy = 0; }
                else if (direction === 'Up') { dx = 0; dy = -1; }
                else if (direction === 'Down') { dx = 0; dy = 1; }
                
                if (dx !== 0 || dy !== 0) {
                    gameStarted = true;
                    gameLoop = setInterval(main, 150);
                }
                return;
            }

            if (inputQueue.length < 2) {
                inputQueue.push(direction);
            }
        }

        function generateFood() {
            foodX = Math.floor(Math.random() * tileCount);
            foodY = Math.floor(Math.random() * tileCount);
            snake.forEach(function isFoodOnSnake(part) {
                if (part.x === foodX && part.y === foodY) generateFood();
            });
        }

        function checkCollision() {
            const head = snake[0];
            for (let i = 1; i < snake.length; i++) {
                if (snake[i].x === head.x && snake[i].y === head.y) return true;
            }
            const hitLeftWall = (head.x < 0);
            const hitRightWall = (head.x >= tileCount);
            const hitTopWall = (head.y < 0);
            const hitBottomWall = (head.y >= tileCount);
            return hitLeftWall || hitRightWall || hitTopWall || hitBottomWall;
        }

        document.addEventListener('keydown', changeDirection);

        canvas.addEventListener('click', (e) => {
            if (gameOver) {
                const rect = canvas.getBoundingClientRect();
                const clickY = e.clientY - rect.top;
                
                if (clickY > CLICK_ZONES.restartY - 20 && clickY < CLICK_ZONES.restartY + 20) {
                    restartGame();
                }
                else if (clickY > CLICK_ZONES.homeY - 20 && clickY < CLICK_ZONES.homeY + 20) {
                    goHome();
                }
            }
        });

        startGame();

    </script>
</body>

</html>
